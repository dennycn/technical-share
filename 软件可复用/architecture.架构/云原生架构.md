| 序号 | 修改时间 | 修改内容                     | 修改人 | 审稿人 |
| ---- | -------- | ---------------------------- | ------ | ------ |
| 1    | 2018-8-4 | 创建。从《微服务架构》拆分。 | 吴启福 |        |
|      |          |                              |        |        |
---

 

 

 

 

# 目录

[TOC]

 









 

 

 

# 1 云原生

定义：云原生技术用于开发一类特别的应用程序，这类应用程序通过容器中的服务构建，然后按照微服务的形式部署，并通过 DevOps 敏捷流程以及可持续交付工作流在弹性基础设施上进行管理。

云原生 = 容器 + 微服务 + 容器编排 + devops（CI/CD）

 

**云原生组织**

*  OCI：开放容器计划（Open Containers Initiative，OCI），这是一个轻量级、开放的治理结构（或项目），在 Linux 基金会的支持下产生，其明确的目的就是围绕容器格式和运行时创建开放的行业标准。

*  **CNCF**，云原生计算基金（Cloud Native Computing Foundation），一个致力于云计算普及化和可持续化的开源软件组织。

## 1.1     云原生CNCF简介

CNCF（Cloud Native Computing Foundation）于 2015 年 7 月成立，隶属于 Linux 基金会，初衷围绕“云原生”服务云计算，致力于维护和集成开源技术，支持编排容器化微服务架构应用。

CNCF 还帮助项目建立了治理结构。CNCF 提出了成熟度级别的概念：沙箱、孵化和毕业。这些级别分别对应下图中的创新者、早期采用者和早期大众。

![CNCF 项目成熟等级.png](../../media/sf_reuse/arch/arch_cncf_001.png)

图 1 CNCF 项目成熟等级

CNCF项目列表 详见 《CNCF云原生框架分析》

## 1.2     云服务成功案例

### 1.2.1  Amazon

电商。1995年创立；2006年推出AWS云服务；2007年推出kindle阅读器进军硬件市场。

 

### 1.2.2  Netflix

流媒体服务提供商。1997年创立；2009，开始使用AWS。

## 1.3     本章小结

[1].     值得考虑的9个开源云原生项目  http://3g.163.com/dy/article/EOSVH9QR0511D3QS.html 

 

# 2  云原生架构

云原生架相关
*  十二要素应用程序：应用程序开发模式的集合。
*  微服务：将单体业务系统分解为独立可部署服务。
*  自服务敏捷基础设施：自服务平台。
*  基于API的协作：通过API进行服务间的交互。
*  搞脆弱性：自我实现和加强的应用程序。

 

## 2.1     云原生特性

云原生架构的特性

*  以云为基础架构IAAS
*  云服务 PAAS+SAAS
*  无服务器架构
*  可扩展：扩展策略有根据资源、时间段、消息队列长度、业务参数和预测。
*  高可用
*  敏捷
*  云优先

### 2.1.1  12-Factor 十二要素

12-Factor 为构建如下的 SaaS（软件即服务） 应用提供了方法论（目标）：
*  使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。
*  和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性。
*  适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源。
*  将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发。
*  可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。
*  这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。


**十二要素详解**

1)  基准代码：一份基准代码（Codebase），多份部署（deploy）。通常会使用版本控制系统加以管理，如Git, Mercurial, Subversion。

2)  依赖：显式声明依赖关系（ dependency ），如maven或setup.py

3) 配置：在环境中存储配置。判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。12-Factor推荐将应用的配置存储于 环境变量 中（ env vars, env ）。

4) 后端服务：把后端服务(backing services)当作附加资源。部署可以按需加载或卸载资源。

5) 构建，发布，运行：严格分离构建和运行。

6) 进程：以一个或多个无状态进程运行应用。任何需要持久化的数据都要存储在 后端服务 内，比如数据库。

7) 端口绑定：通过端口绑定(Port binding)来提供服务。12-Factor 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。

8) 并发：通过进程模型进行扩展。

9) 易处理：快速启动和优雅终止可最大化健壮性。易处理（disposable）的，意思是说它们可以瞬间开启或停止。这有利于快速、弹性的伸缩应用，迅速部署变化的 代码 或 配置 ，稳健的部署应用。

10) 开发环境与线上环境等价：尽可能的保持开发，预发布，线上环境相同。缩小时间、人员和工具差异。

11) 日志：把日志当作事件流。

12) 管理进程：后台管理任务当作一次性进程运行。

 

## 2.2     云原生参考架构

表格 1 云原生参考架构

| 参考架构                      | 部署特点                       | 扩展性               | 可用性      | 安全性         |
| ----------------------------- | ------------------------------ | -------------------- | ----------- | -------------- |
| WEB应用的IAAS部署             | 基于VM                         | 向上（加资源）、横向 | 多节点、SLA | 防火墙、HTTPS  |
| WEB应用的PAAS部署             | 基于DOCKER、K8S管理            | 横向、POD            | 多POD       | 防火墙、HTTPS  |
| WEB应用的云原生架构           | SpringCloud、K8S               | 横向                 | 多实例      | 防火墙、HTTPS  |
| WEB应用的多站点部署（云原生） | SpringCloud、K8S、多数据中心DC | 横向、DC扩容         | 多实例      | 防火墙、HTTPS  |
| SAAS应用的混合云集成          | LDAP                           | 用户定义SLA          |             | 防火墙、HTTPS  |
| IOT应用的云原生架构           | 消息驱动、大数据               | 横向                 |             | IOT网关、HTTPS |

 

## 2.3     本章小结

[2].     容器编排巅峰对决-Mesos/Swarm/Kubernetes比较 https://www.sohu.com/a/157185937_287582

[3].     拿下中石油千万级大单，灵雀云如何在容器行业脱颖而出 | 爱分析调研  [www.sohu.com/a/240907122_545428](http://www.sohu.com/a/240907122_545428)

[4].     云原生应用的12要素  http://blog.didispace.com/12factor-zh-cn/ 



# 3  云原生设计模式

## 3.1     云原生设计模式

表格2 云开发领域问题（八类）~来自于windows Azure

| 类别         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| 可用性       | 可用性指系统正常工作时间所占的比例，通常以运行时间百分比度量。 可用性受系统错误、基础结构问题、恶意攻击和系统负载的影响。  云应用程序通常向用户提供服务级别协议 (SLA)，因此，它们在设计上必须能够最大程度地保持可用性。 |
| 数据管理     | 数据管理是云应用程序的关键要素，影响大部分质量属性。 出于性能、可伸缩性或可用性等方面的原因，数据通常托管在不同的位置并跨多个服务器，这可能会带来一系列的挑战。 例如，必须保持数据一致性，通常需要将不同位置的数据进行同步。 |
| 设计和实现   | 合理的设计包括很多因素（例如组件设计和部署中的一致性与连贯性）、可简化管理和部署的可维护性，以及可允许在其他应用程序和其他方案中使用的组件和子系统的可重用性。 在设计和实施阶段做出的决策对云托管应用程序和服务的质量和总拥有成本具有巨大影响。 |
| 消息传送     | 云应用程序的分布性要求消息基础结构在理想情况下能以松散耦合的方式连接组件和服务，从而将可伸缩性最大化。 异步消息受到广泛使用并提供了诸多好处，但也带来了许多挑战，如消息排序、有害消息管理和幂等性等。 |
| 管理和监控   | 云应用程序在远程数据中心内运行，在此中心内，无法完全控制基础结构，或者在某些情况下无法控制操作系统。 与本地部署相比，管理和监视难度更大。 应用程序必须公开运行时信息，以便管理员和操作员管理和监视系统，支持不断变化的业务要求和定制，而无需停止或重新部署应用程序。 |
| 性能和伸缩性 | 性能是指系统在给定的时间间隔内执行任何操作的响应能力，可伸缩性则是系统能够应对负载增大且不影响性能或随时增加可用资源的能力。 云应用程序往往会遇到可变工作负载和活动高峰。 预测这些变化（尤其是在多租户方案中）几乎是不可能的。 应用程序应该能够在限制范围内扩大以满足需求高峰，并在需求减少时缩小。 可伸缩性不仅涉及计算实例，而且还涉及其他要素，例如数据存储、消息传送基础结构，等等。 |
| 弹性         | 复原能力是指系统能够在发生故障后进行恰当处理，然后恢复正常。 由于云托管的性质（应用程序通常是多租户的、使用共享平台服务、争用资源和带宽、通过 Internet 通信、在市售硬件上运行），出现暂时性故障和持久性故障的可能性增大。 快速高效检测故障并恢复是保持复原能力所必需的。 |
| 安全性       | 安全性是防止超出设计使用范围的恶意或意外操作，并防止泄露或丢失信息的系统能力。 云应用程序暴露在受信任的本地边界之外的 Internet 上，通常向公众开放，并可能为不受信任的用户提供服务。 应用程序的设计和部署必须防范它们受到恶意攻击，将访问权限限制给经过批准的用户，并保护敏感数据。 |



表格  云原生设计模式~来自于windows Azure (37种更新，new)

| 模式                                                         | 摘要                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [代表](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/ambassador) | 创建代表客户服务或应用程序发送网络请求的帮助程序服务。       |
| [防损层](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/anti-corruption-layer) | 在现代应用程序与旧系统之间实施外观或适配器层。               |
| [异步请求-答复](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/async-request-reply) | 在后端处理需要是异步处理但前端仍需要明确响应的情况下，将后端处理与前端主机分离。 |
| [用于前端的后端](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/backends-for-frontends) | 创建单独的后端服务，供特定的前端应用程序或接口使用。         |
| [隔层](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/bulkhead) | 将应用程序的元素隔离到池中，这样，如果一个元素发生失败，其他元素可继续工作。 |
| [缓存端](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/cache-aside) | 将数据按需从数据存储加载到缓存中                             |
| [协调](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/choreography) | 让每项服务都参与决定业务运营的处理时间和处理方式，而不是依赖于一个中心型业务流程协调程序。 |
| [断路器](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/circuit-breaker) | 连接到远程服务或资源时处理故障，此类故障所需修复时间不定。   |
| [声明检查](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/claim-check) | 将大型消息拆分成声明检查和有效负载，以免消息总线过载。       |
| [补偿事务](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/compensating-transaction) | 撤销一系列会共同定义最终一致操作的工作。                     |
| [竞争性使用者](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/competing-consumers) | 使多个并发使用者能够处理同一消息通道上收到的消息。           |
| [计算资源合并](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/compute-resource-consolidation) | 将多个任务或操作合并到单个计算单元                           |
| [CQRS](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/cqrs) | 使用独立接口将读取数据的操作与更新数据的操作分离。           |
| [事件溯源](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/event-sourcing) | 使用只追加存储来记录描述域中数据采取的操作的完整系列事件。   |
| [外部配置存储](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/external-configuration-store) | 将配置信息从应用程序部署包移出，移到一个集中的位置。         |
| [联合标识](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/federated-identity) | 将身份验证委托给外部标识提供者。                             |
| [守护程序](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/gatekeeper) | 通过使用专用的主机实例保护应用程序和服务，该实例用于充当客户端和应用程序或服务之间的中转站、验证和整理请求，并在它们之间传递请求和数据。 |
| [网关聚合](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/gateway-aggregation) | 使用网关可将多个单独请求聚合成一个请求。                     |
| [网关卸载](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/gateway-offloading) | 将共享或专用服务功能卸载到网关代理。                         |
| [网关路由](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/gateway-routing) | 使用单个终结点将请求路由到多个服务。                         |
| [运行状况终结点监视](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/health-endpoint-monitoring) | 在应用程序中实施可让外部工具通过公开终结点定期访问的功能检查。 |
| [索引表](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/index-table) | 基于数据存储中经常由查询引用的字段创建索引。                 |
| [领导选拔](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/leader-election) | 通过选拔一个实例作为领导来负责管理其他实例，协调分布式应用程序中协作性任务实例集合所执行的操作。 |
| [具体化视图](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/materialized-view) | 当未针对所需的查询操作完美设置数据的格式时，在一个或多个数据存储中基于数据生成预填充的视图。 |
| [管道和筛选器](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/pipes-and-filters) | 将一个执行复杂处理的任务分解为一系列可重复使用的单个元素。   |
| [优先级队列](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/priority-queue) | 为发送到服务的请求确定优先级，以便高优先级请求能够得到比低优先级请求更快速地接收和处理。 |
| [发布方/订阅方](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/publisher-subscriber) | 使应用程序能够以异步方式向多个感兴趣的使用者公布事件，而无需将发送方与接收方耦合。 |
| [基于队列的负载调控](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/queue-based-load-leveling) | 使用队列在任务与所调用的服务之间充当缓冲，从而缓解间歇性负载过大现象。 |
| [重试](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/retry) | 当应用程序尝试连接到服务或网络资源时，使应用程序能够通过以透明方式重试先前失败的操作来处理预期的临时故障。 |
| [计划程序代理监督程序](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/scheduler-agent-supervisor) | 跨一组分布式服务和其他远程资源协调一组操作。                 |
| [分片](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/sharding) | 将数据存储划分为一组水平分区或分片。                         |
| [Sidecar](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/sidecar) | 将应用程序的组件部署到单独的进程或容器中，以提供隔离和封装。 |
| [静态内容托管](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/static-content-hosting) | 将静态内容部署到基于云的存储服务，再由后者将它们直接传送给客户端。 |
| [Strangler](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/strangler) | 通过将特定的功能片断逐渐取代为新的应用程序和服务，逐步迁移旧系统。 |
| [限制](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/throttling) | 控制应用程序实例、单个租户或整个服务对资源的消耗。           |
| [附属密钥](https://docs.microsoft.com/zh-cn/azure/architecture/patterns/valet-key) | 使用令牌或密钥，向客户端授予对特定资源或服务的受限直接访问权限。 |



表格3 云原生设计模式~来自于windows Azure (24种，2015)

| 模式名             | 描述                                                       | 应用场景                                                     |
| ------------------ | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 缓存驻留           | 根据需要从数据存储器加载数据。                             | 此模式可以用来改进性能，用于维护缓存和后台数据库的数据一致性。 |
| 断路器             | 当连接远程服务或资源时，可能导致不定时间恢复系统的错误     | 用于改进系统的稳定性和弹性。                                 |
| 事务补偿           | 如果一个或多个操作失败，就会取消执行的一系列工作。         | 遵从最终一致性模型。通常用于实现复杂的业务过程和工作流。     |
| 竞争消费者         | 允许多个并发消费者在相同的消息通道上处理接收的消息         |                                                              |
| 计算资源合并       |                                                            |                                                              |
| 命令和职责分离     | 通过隔离接口来分离更新和读操作。                           |                                                              |
| 事件溯源           | 使用只能追加的存储库来记录领域里数据库的完整操作序列。     |                                                              |
| 外部配置存储       | 把配置信息从应用部署包移动到一个中心位置。（应用配置中心） |                                                              |
| 联合身份           |                                                            |                                                              |
| 门卫               |                                                            |                                                              |
| 健康终结点监控     | 在应用中实现功能检查。                                     |                                                              |
| 索引表             |                                                            |                                                              |
| 领导选举           |                                                            |                                                              |
| 物化视图           |                                                            |                                                              |
| 管道和过滤器       |                                                            |                                                              |
| 优先级队列         |                                                            |                                                              |
| 基于队列的负载均衡 |                                                            |                                                              |
| 重试               |                                                            |                                                              |
| 运行时配置         |                                                            |                                                              |
| 调试器代理监控     |                                                            |                                                              |
| 分片               |                                                            | 存储和访问海量数据时，改进伸缩性。                           |
| 静态内容托管       |                                                            |                                                              |
| 限流               |                                                            |                                                              |
| 令牌               |                                                            |                                                              |



表格4  云原生设计模式列表

| DFX      | 模式名   | 模式简介                           |
| -------- | -------- | ---------------------------------- |
| 可用性   | 限流     |                                    |
|          | 熔断器   |                                    |
|          | 断路器   |                                    |
|          | RETRY    | 超时重试。                         |
|          | 服务降级 | 按降级粒度可分为接口、功能和服务。 |
|          |          |                                    |
| 安全性   |          |                                    |
| 可扩展性 | ROUTE    |                                    |
|          |          |                                    |

 

## 3.2     容器设计模式

区别于之前的面向对象的设计模式。

 表格 5 容器设计模式列表

| 容器数           | 模式名                                 | 模式简介                                                     |
| ---------------- | -------------------------------------- | ------------------------------------------------------------ |
| 单容器           |                                        |                                                              |
| 单节点多容器组合 | 跨斗模式（Sidecar pattern）            | 多容器通过共享文件系统形成本地通信，共同提供一个微服务。     |
|                  | 外交官模式（Ambassador pattern）       | 应用容器和外交官容器共享一个网络IP地址，应用容器利用这个可重用的外交官容器作为代理来访问远程服务或资源。 |
|                  | 适配器模式（Adapter pattern）          | 应用容器提供应用功能，同时和一个适配器容器共享文件系统和一个网络IP地址，分布式系统管理平台可以利用适配器容器的统一接口，从应用容器收集日志和监控数据等信息。 |
| 多节点组合       | 选举模式（Election pattern）           | 一个可重用的选举器容器跟应用容器组合起来，提供为在分布式系统中的多个应用实例选举主控节点的问题。 |
|                  | 工作队列模式（Work queue pattern）     | 应用容器跟可重用的队列消息处理器，共同工作，可以并行地处理队列中海量的同类型并行计算业务。 |
|                  | 分散收集模式（Scatter/gather pattern） | 通过先将大任务分割成诸多小任务处理，在收集汇总合并产生最终结果的模式，支持复杂任务的分布式计算。 |

## 3.3     本章小结

[1]:    https://www.jianshu.com/p/020f699c41e6  "容器设计模式"
[2]:   http://www.dockerinfo.net/2067.html	"《Kubernetes与云原生应用》之容器设计模式"
[3]:     www.dockone.io/article/1547(http://www.dockone.io/article/1547)  "基于容器的分布式系统的设计模式"
[4]:  https://docs.microsoft.com/zh-cn/azure/architecture/patterns/  "windows azure云设计模式（持续更新）"

[5]:   https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn568099(v=pandp.10)   “Cloud Design Patterns: Prescriptive Architecture Guidance for Cloud Applications (2015)”  

 

# 4  容器编排

## 4.1     容器编排技术选型

编排Orchestration这一术语来源于音乐领域，根据作曲家的作品，编曲决定音乐作品的某一部分由某种乐器以某种方式在某个时机来演奏，这一过程称为编排。

编排这一术语被借用到了IT领域，

*  Service Orchestration： 在SOA和微服务体系中，针对Service。

*  Cloud Orchestration：在Cloud 体系中，针对云资源描述。

*  容器编排：负责容器的启停调度，并且通过管理容器集群来提升容器使用率。

 

表格6  容器编排K8s/Mesos/Swarm比较

|          | K8s                                                          | Mesos                                                        | Swarm                                                        |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 简介     | 基于Google在过去十五年来大量生产环境中运行工作负载的经验。  高度通用，开源。 | 分布式调度系统内核。作为资源管理器的Apache Mesos在容器之前就已经出现很久了，支持运行容器化化和非容器化的工作负载。  适用于大型系统 | Docker开发的调度框架。  标准Docker API的使用。  易于集成和设置，灵活的API，有限的定制。 |
| 支撑厂商 | Google                                                       | Mesosphere                                                   | Docker                                                       |
| 核心概念 | APIServer Pod Label  Service  kubelet                        | Master Slave   Zookeeper Framework                           |                                                              |
| 特性     | 通过Pods这一抽象的概念，解决Container之间的依赖于通信问题。Pods,  Services, Deployments是独立部署的部分，可以通过Selector提供更多的灵活性。内置服务注册表和负载平衡。 | 可以支持应用程序的健康检查，开放的架构。支持多个框架和多个调度器，通过不同的Framework可以运行Haddop/Spark/MPI等多种不同的任务。 | 由于随Docker引擎一起发布，无需额外安装，配置简单。支持服务注册、服务发现，内置Overlay Network以及Load Balancer。与Docker CLI非常类似的操作命令，对熟悉Docker的人非常容易上手学习。 |

备注：2016年容器三家平分秋色；到2017年，k8s成为主流。



### 4.1.1  K8s

详见 下方Kubernetes

Kubernetes的实现参考了Google内部的资源调度框架，但并不是Borg的内部容器编排系统的开源，而是借鉴Google从运行Borg获得的经验教训，形成了Kubernetes项目。它使用Label和Pod的概念来将容器划分为逻辑单元。Pods是同地协作（co-located）容器的集合，这些容器被共同部署和调度，形成了一个服务，这是Kubernetes和其他两个框架的主要区别。相比于基于相似度的容器调度方式（就像Swarm和Mesos），这个方法简化了对集群的管理。

![img](../../media/sf_reuse/arch/arch_cncf_002.png)

图 2 K8s结构

ubernetes基本概念：
*  ControlPlane：暴露应用程序接口（API），调度部署和管理整个集群。
*  WorkerNodes：物理或者虚拟的服务器，负责运行工作负载。
*  APIServer：外部与Kubernetes的互动点。
*  Etcd：默认采用CoreOS 的产品etcd ，提供键值存储、服务发现、服务注册功能。
*  Kubelet：节点上的代理，负责执行Kubernetes Master分配的任务。
*  Pods:由同一主机上部署的一个或几个容器组成的计算能力单位，执行相同的任务。
*  Services：Pods的前端和Load Balancer ,为Pods提供Floating IP。
*  Replicationcontrollers：负责维护指定数目的 Pods。
*  Labels：key-value标签以一种非层次化、松散的方式标记、查找Kubernetes中的Pods/Replication Controllers/Services等资源。


### 4.1.2  Mesos

Mesos是一个分布式调度系统内核，早于Docker产生，Mesos 作为资源管理器，从DC/OS(数据中心操作系统)的角度提供资源视图。主/从结构工作模式，主节点分配任务，并用从节点上的Executor负责执行，通过Zookeeper给主节点提供服务注册、服务发现功能。通过Framework Marathon 提供容器调度的能力。

![img](../../media/sf_reuse/arch/arch_cncf_003.png)

图 3 Mesos主从结构

Mesos主要基本概念：
*  Mesos Master：将作业分配给Slave节点，并将资源提供给Framework.
*  Mesos Slave：运行Mesos Agent ,并执行执行分配的任务。
*  Zookeeper：服务注册、服务发现，同时可以在高可用的环境中选取Master节点。
*  Framework：资源的二度调度框架，通过在Agent上部署Executor来执行计划的任务。Mesos支持的Framework 有Hadoop/Spark/MPI/Marathon，通过Marathon Framework完成容器编排的功能。

 

### 4.1.3  Docker Swarm

Docker Swarm是一个由Docker开发的调度框架。由Docker自身开发的好处之一就是标准Docker API的使用，Swarm由多个代理（Agent）组成，把这些代理称之为节点（Node）。这些节点就是主机，这些主机在启动Docker Daemon的时候就会打开相应的端口，以此支持Docker远程API。这些机器会根据Swarm调度器分配给它们的任务，拉取和运行不同的镜像。

![img](../../media/sf_reuse/arch/arch_cncf_004.png)

图 4 Docker Swarm结构

Swarm基本概念：
*  Manager：在整个集群中分配任务，集群中控制Worker的节点。
*  Worker：运行由Manager节点分配的任务.
*  Services：跨节点的执行特定接口的一组容器。.
*  Key-valuestore：内建的Key-Value存储解决方案，做服务发现、服务注册以及主节点选举工作。


# 5  Service Mesh

Service Mesh是专用的基础设施层，用于使服务之间通信安全，快速和可靠。

service mesh是用于处理服务与服务之间通信的专用基础设施层。 它负责在包含现代化、云原生应用且拓扑复杂的服务之间可靠地传递请求。 实际上，service mesh通过一系列轻量网络代理来实现，这些代理与应用程序代码一起部署，而且对应用程序不感知。

表格 6  服务发现模式列表

| 模式             | 优点                         | 不足                                       | 适用场景                             | 案例 |
| ---------------- | ---------------------------- | ------------------------------------------ | ------------------------------------ | ---- |
| 集中式代理       | 运维简单、集中治理、语言无关 | 配置麻烦周期长、单点问题、多一跳有性能开销 | 中大小规模公司都适用，需一定运维能力 |      |
| 客户端嵌入式代理 | 无单点、性能好               | 客户端复杂、多语言麻烦、治理松散           | 中大规模公司，语言栈较统一           |      |
| 主机独立进程代理 | 折中方案                     | 运维部署复杂                               | 中大规模公司，运维能力强             |      |



# 参考资料

参考书籍
* 《云计算架构设计模式》 微软模式与实践小组（微软P&P小组） 华中科技大学出版社  2017年10月 
* 《云计算设计模式》 机械工业出版社  2016.5



参考资料

[1].     基于 Docker 的微服务架构实践 https://www.jianshu.com/p/f78864310827 

